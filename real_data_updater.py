#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
–ó–∞–≥—Ä—É–∑—á–∏–∫ –¥–∞–Ω–Ω—ã—Ö –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏ –¥–ª—è —Ç–æ—Ä–≥–æ–≤–æ–π —Å–∏—Å—Ç–µ–º—ã –ò—à–∏–º–æ–∫—É
–û–±–Ω–æ–≤–ª—è–µ—Ç –¥–∞–Ω–Ω—ã–µ –¥–ª—è –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –≤–∞–ª—é—Ç–Ω—ã—Ö –ø–∞—Ä –∏ —Ç–∞–π–º—Ñ—Ä–µ–π–º–æ–≤ –∏–∑ OANDA API
–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç: M5, M15, M30, H1, H4 –¥–ª—è –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º–æ–≥–æ —Å–ø–∏—Å–∫–∞ –≤–∞–ª—é—Ç–Ω—ã—Ö –ø–∞—Ä
"""

import sys
import os
import time
import logging
import requests
import psycopg2
from psycopg2.extras import execute_values
from datetime import datetime, timedelta
import json
from typing import List, Dict, Optional, Tuple
import signal
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed
import queue

# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
from real_config import (
    get_active_config, NOTIFICATION_TYPES, 
    get_all_combinations, get_enabled_pairs, get_timeframe_by_name,
    get_data_download_combinations, get_all_pairs
)

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
class UTCFormatter(logging.Formatter):
    """–ö–∞—Å—Ç–æ–º–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç—Ç–µ—Ä –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏ –≤ UTC"""
    def formatTime(self, record, datefmt=None):
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º UTC –≤—Ä–µ–º—è –≤–º–µ—Å—Ç–æ –º–µ—Å—Ç–Ω–æ–≥–æ
        ct = datetime.utcfromtimestamp(record.created)
        if datefmt:
            return ct.strftime(datefmt)
        else:
            return ct.strftime('%Y-%m-%d %H:%M:%S') + ' UTC'

def setup_logging(config):
    """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Å–∏—Å—Ç–µ–º—ã –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è"""
    log_config = config['logging']
    
    # –°–æ–∑–¥–∞–µ–º UTC formatter
    formatter = UTCFormatter(log_config['format'])
    
    # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π –ª–æ–≥–≥–µ—Ä
    logger = logging.getLogger('MultiPairDataUpdater')
    logger.setLevel(getattr(logging, log_config['level']))
    
    # File handler —Å —Ä–æ—Ç–∞—Ü–∏–µ–π
    from logging.handlers import RotatingFileHandler
    file_handler = RotatingFileHandler(
        'real_data_updater.log',
        maxBytes=log_config['max_file_size'],
        backupCount=log_config['backup_count'],
        encoding='utf-8'
    )
    file_handler.setFormatter(formatter)
    logger.addHandler(file_handler)
    
    # Console handler
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)
    
    return logger

class TelegramNotifier:
    """–ö–ª–∞—Å—Å –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –≤ Telegram"""

    def __init__(self, config, logger):
        self.config = config['telegram']
        self.logger = logger
        self.session = requests.Session()

    def send_message(self, message: str, topic_type: str = 'system'):
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ Telegram"""
        try:
            topic_id = self.config['topics'].get(topic_type, self.config['topics']['system'])

            url = f"https://api.telegram.org/bot{self.config['bot_token']}/sendMessage"

            data = {
                'chat_id': self.config['chat_id'],
                'text': message,
                'parse_mode': 'HTML',
                'message_thread_id': topic_id
            }

            for attempt in range(self.config['retry_attempts']):
                try:
                    response = self.session.post(url, json=data, timeout=10)
                    if response.status_code == 200:
                        return True
                    else:
                        self.logger.warning(f"Telegram API –ø–æ–º–∏–ª–∫–∞: {response.status_code}")

                except requests.RequestException as e:
                    self.logger.warning(f"–ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥–ø—Ä–∞–≤–∫–∏ –≤ Telegram (—Å–ø—Ä–æ–±–∞ {attempt + 1}): {e}")

                if attempt < self.config['retry_attempts'] - 1:
                    time.sleep(self.config['retry_delay'])

            return False

        except Exception as e:
            self.logger.error(f"–ö—Ä–∏—Ç–∏—á–Ω–∞ –ø–æ–º–∏–ª–∫–∞ Telegram: {e}")
            return False

class MultiPairDataUpdater:
    """–û—Å–Ω–æ–≤–Ω–æ–π –∫–ª–∞—Å—Å –∑–∞–≥—Ä—É–∑—á–∏–∫–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –ø–∞—Ä"""
    
    def __init__(self):
        self.config = get_active_config()
        self.logger = setup_logging(self.config)
        
        self.running = False
        self.db_connection = None
        self.combinations = self.config['data_download_combinations']
        
        # OANDA API –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
        self.oanda_session = requests.Session()
        self.oanda_session.headers.update({
            'Authorization': f"Bearer {self.config['oanda']['api_key']}",
            'Content-Type': 'application/json'
        })
        
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        self.stats = {
            'total_updates': 0,
            'successful_updates': 0,
            'failed_updates': 0,
            'start_time': None,
            'last_update_time': None,
            'pair_stats': {}
        }
        
        # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–∏–≥–Ω–∞–ª–æ–≤ –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
        signal.signal(signal.SIGINT, self._signal_handler)
        signal.signal(signal.SIGTERM, self._signal_handler)
        
        self.logger.info("üöÄ –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –±–∞–≥–∞—Ç–æ–ø–∞—Ä–Ω–æ–≥–æ –∑–∞–≤–∞–Ω—Ç–∞–∂—É–≤–∞—á–∞ –¥–∞–Ω–∏—Ö –∑–∞–≤–µ—Ä—à–µ–Ω–∞")
        self.logger.info(f"üìä –ë—É–¥–µ –æ–±—Ä–æ–±–ª—è—Ç–∏—Å—è {len(self.combinations)} –∫–æ–º–±—ñ–Ω–∞—Ü—ñ–π –ø–∞—Ä/—Ç–∞–π–º—Ñ—Ä–µ–π–º—ñ–≤")
        self.logger.info(f"üí± –í—Å—å–æ–≥–æ –≤–∞–ª—é—Ç–Ω–∏—Ö –ø–∞—Ä: {len(get_all_pairs())} (–≤–∫–ª—é—á–∞—é—á–∏ –Ω–µ–∞–∫—Ç–∏–≤–Ω—ñ)")
        self.logger.info(f"üìà –ê–∫—Ç–∏–≤–Ω–∏—Ö —Ç–∞–π–º—Ñ—Ä–µ–π–º—ñ–≤: {len(self.config['active_timeframes'])}")
    
    def _signal_handler(self, signum, frame):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–∏–≥–Ω–∞–ª–æ–≤ –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è"""
        self.logger.info(f"üì° –û—Ç—Ä–∏–º–∞–Ω–æ —Å–∏–≥–Ω–∞–ª {signum}, –∑—É–ø–∏–Ω—è—î–º–æ —Å–∏—Å—Ç–µ–º—É...")
        self.running = False
    
    def connect_to_database(self):
        """–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö"""
        try:
            db_config = self.config['database']
            self.db_connection = psycopg2.connect(
                host=db_config['host'],
                port=db_config['port'],
                database=db_config['database'],
                user=db_config['user'],
                password=db_config['password']
            )
            self.db_connection.autocommit = False
            
            # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º UTC
            cursor = self.db_connection.cursor()
            cursor.execute("SET timezone = 'UTC'")
            cursor.close()
            
            self.logger.info("‚úÖ –ü—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –¥–æ –±–∞–∑–∏ –¥–∞–Ω–∏—Ö –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ")
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –¥–æ –ë–î: {e}")
            self.telegram.send_message(
                f"‚ùå <b>–ü–æ–º–∏–ª–∫–∞ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –¥–æ –±–∞–∑–∏ –¥–∞–Ω–∏—Ö</b>\n{str(e)[:200]}", 
                'system'
            )
            return False
    
    def get_last_candle_time(self, combination: Dict) -> Optional[datetime]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –ø–æ—Å–ª–µ–¥–Ω–µ–π —Å–≤–µ—á–∏ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ –ø–∞—Ä–∞/—Ç–∞–π–º—Ñ—Ä–µ–π–º"""
        try:
            cursor = self.db_connection.cursor()
            query = """
                SELECT MAX(timestamp) AT TIME ZONE 'UTC' as utc_timestamp
                FROM market_data.candles 
                WHERE symbol_id = %s AND timeframe_id = %s
            """
            cursor.execute(query, (combination['symbol_id'], combination['timeframe_id']))
            
            result = cursor.fetchone()
            cursor.close()
            
            if result and result[0]:
                # –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º UTC timezone
                last_time = result[0]
                from datetime import timezone
                if last_time.tzinfo is None:
                    last_time = last_time.replace(tzinfo=timezone.utc)
                elif last_time.tzinfo != timezone.utc:
                    # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ UTC –µ—Å–ª–∏ –¥—Ä—É–≥–æ–π timezone
                    last_time = last_time.astimezone(timezone.utc)
                
                self.logger.debug(f"üìÖ –û—Å—Ç–∞–Ω–Ω—è —Å–≤—ñ—á–∫–∞ {combination['symbol']} {combination['timeframe']}: {last_time} UTC")
                return last_time
            else:
                self.logger.warning(f"‚ö†Ô∏è –°–≤—ñ—á–∫–∏ –¥–ª—è {combination['symbol']} {combination['timeframe']} –Ω–µ –∑–Ω–∞–π–¥–µ–Ω—ñ")
                return None
                
        except Exception as e:
            self.logger.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –æ—Å—Ç–∞–Ω–Ω—å–æ—ó —Å–≤—ñ—á–∫–∏ {combination['symbol']} {combination['timeframe']}: {e}")
            return None
    
    def parse_oanda_time(self, time_str: str) -> datetime:
        """–ü–∞—Ä—Å–∏–Ω–≥ –≤—Ä–µ–º–µ–Ω–∏ OANDA –≤ —Ñ–æ—Ä–º–∞—Ç–µ UTC"""
        try:
            # OANDA —Ñ–æ—Ä–º–∞—Ç: 2023-01-11T15:27:00.000000000Z
            if '.' in time_str:
                date_part, microsec_part = time_str.split('.')
                microsec_part = microsec_part[:6].ljust(6, '0')
                time_str = f"{date_part}.{microsec_part}Z"
            
            time_str = time_str.replace('Z', '+00:00')
            return datetime.fromisoformat(time_str)
            
        except Exception as e:
            self.logger.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥—É —á–∞—Å—É: {time_str}, {e}")
            raise
    
    def fetch_new_candles(self, from_time: datetime, combination: Dict, last_db_time: Optional[datetime] = None, to_time: Optional[datetime] = None) -> List[Dict]:
        """–ó–∞–≥—Ä—É–∑–∫–∞ –Ω–æ–≤—ã—Ö —Å–≤–µ—á–µ–π —Å OANDA API –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –ø–∞—Ä—ã/—Ç–∞–π–º—Ñ—Ä–µ–π–º–∞"""
        try:
            # –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º —Å–≤–µ—á–∏ –Ω–∞—á–∏–Ω–∞—è —Å –ø–æ—Å–ª–µ–¥–Ω–µ–π –∏–∑–≤–µ—Å—Ç–Ω–æ–π (–≤–∫–ª—é—á–∏—Ç–µ–ª—å–Ω–æ)
            from_time_str = from_time.isoformat().replace('+00:00', 'Z')
            
            params = {
                'granularity': combination['oanda_format'],
                'from': from_time_str,
            }
            
            if to_time:
                # –ï—Å–ª–∏ —É–∫–∞–∑–∞–Ω to_time (–¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –∏—Å—Ç–æ—Ä–∏–∏), –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ
                to_time_str = to_time.isoformat().replace('+00:00', 'Z')
                params['to'] = to_time_str
            else:
                # –î–ª—è –æ–±—ã—á–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º count
                params['count'] = self.config['data_update']['candles_to_fetch']
            
            url = f"{self.config['oanda']['api_url']}/v3/instruments/{combination['symbol']}/candles"
            
            self.logger.debug(f"üì• {combination['symbol']} {combination['timeframe']}: –∑–∞–ø–∏—Ç –∑ {from_time_str}")
            
            response = self.oanda_session.get(
                url, 
                params=params, 
                timeout=self.config['oanda']['request_timeout']
            )
            
            # –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–¥–µ—Ä–∂–∫—É –¥–ª—è —Å–æ–±–ª—é–¥–µ–Ω–∏—è –ª–∏–º–∏—Ç–æ–≤ API
            time.sleep(self.config['oanda']['rate_limit_delay'])
            
            if response.status_code == 200:
                data = response.json()
                candles = data.get('candles', [])
                
                self.logger.info(f"üì• {combination['symbol']} {combination['timeframe']}: OANDA –ø–æ–≤–µ—Ä–Ω—É–≤ {len(candles)} —Å–≤—ñ—á–æ–∫")
                
                # –ü—Ä–∏–≤–æ–¥–∏–º from_time –∫ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º—É —Ñ–æ—Ä–º–∞—Ç—É –ü–ï–†–ï–î —Ü–∏–∫–ª–æ–º
                from datetime import timezone
                if from_time.tzinfo is None:
                    from_time = from_time.replace(tzinfo=timezone.utc)
                
                # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –ø–æ–ª—É—á–µ–Ω–Ω—ã–µ —Å–≤–µ—á–∏
                complete_candles = []
                incomplete_candles = []
                new_candles = []
                
                for candle in candles:
                    candle_time = self.parse_oanda_time(candle['time'])
                    is_complete = candle.get('complete', True)
                    
                    if is_complete:
                        complete_candles.append(candle)
                        
                        # –§–∏–ª—å—Ç—Ä—É–µ–º –Ω–æ–≤—ã–µ —Å–≤–µ—á–∏: –µ—Å–ª–∏ –µ—Å—Ç—å last_db_time, –±–µ—Ä–µ–º —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ –Ω–µ–≥–æ
                        # –µ—Å–ª–∏ –Ω–µ—Ç - –±–µ—Ä–µ–º –≤—Å–µ (–ø–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞)
                        if last_db_time is None:
                            new_candles.append(candle)
                        elif candle_time > last_db_time:
                            # –ë–µ—Ä–µ–º —Ç–æ–ª—å–∫–æ —Å–≤–µ—á–∏ —Å—Ç—Ä–æ–≥–æ –ø–æ—Å–ª–µ –ø–æ—Å–ª–µ–¥–Ω–µ–π –≤ –ë–î
                            new_candles.append(candle)
                    else:
                        incomplete_candles.append(candle)
                
                # –î–µ—Ç–∞–ª—å–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
                self.logger.debug(f"üì• {combination['symbol']} {combination['timeframe']}: –æ—Ç—Ä–∏–º–∞–Ω–æ {len(candles)} –≤—Å—å–æ–≥–æ —Å–≤—ñ—á–æ–∫, –∑–∞–≤–µ—Ä—à–µ–Ω–∏—Ö {len(complete_candles)}")
                if last_db_time:
                    self.logger.debug(f"üïê {combination['symbol']} {combination['timeframe']}: —Ñ—ñ–ª—å—Ç—Ä –ø—ñ—Å–ª—è {last_db_time.strftime('%Y-%m-%d %H:%M:%S')} UTC")
                else:
                    self.logger.debug(f"üïê {combination['symbol']} {combination['timeframe']}: –ø–æ—á–∞—Ç–∫–æ–≤–µ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –±–µ–∑ —Ñ—ñ–ª—å—Ç—Ä—É")
                
                if new_candles:
                    first_new = self.parse_oanda_time(new_candles[0]['time'])
                    last_new = self.parse_oanda_time(new_candles[-1]['time'])
                    self.logger.info(f"üìà {combination['symbol']} {combination['timeframe']}: –∑–Ω–∞–π–¥–µ–Ω–æ {len(new_candles)} –Ω–æ–≤–∏—Ö —Å–≤—ñ—á–æ–∫ ({first_new.strftime('%H:%M')} - {last_new.strftime('%H:%M')} UTC)")
                else:
                    if complete_candles:
                        last_candle = self.parse_oanda_time(complete_candles[-1]['time'])
                        self.logger.info(f"‚ÑπÔ∏è {combination['symbol']} {combination['timeframe']}: –Ω–æ–≤–∏—Ö —Å–≤—ñ—á–æ–∫ –Ω–µ–º–∞—î (–æ—Å—Ç–∞–Ω–Ω—è –≤ OANDA: {last_candle.strftime('%Y-%m-%d %H:%M:%S')} UTC)")
                    else:
                        self.logger.info(f"‚ÑπÔ∏è {combination['symbol']} {combination['timeframe']}: –Ω–µ–º–∞—î –∑–∞–≤–µ—Ä—à–µ–Ω–∏—Ö —Å–≤—ñ—á–æ–∫ –≤—ñ–¥ OANDA")
                
                # –ü—Ä–æ–≥–Ω–æ–∑ —Å–ª–µ–¥—É—é—â–µ–π —Å–≤–µ—á–∏ —Ç–æ–ª—å–∫–æ –¥–ª—è –∫–æ—Ä–æ—Ç–∫–∏—Ö —Ç–∞–π–º—Ñ—Ä–µ–π–º–æ–≤
                if incomplete_candles and combination['timeframe'] in ['M5', 'M15']:
                    next_candle_time = self.parse_oanda_time(incomplete_candles[0]['time'])
                    tf_config = get_timeframe_by_name(combination['timeframe'])
                    expected_completion = next_candle_time + timedelta(minutes=tf_config['minutes'])
                    minutes_left = (expected_completion - datetime.utcnow().replace(tzinfo=expected_completion.tzinfo)).total_seconds() / 60
                    self.logger.debug(f"‚è∞ {combination['symbol']} {combination['timeframe']}: –Ω–∞—Å—Ç—É–ø–Ω–∞ —Å–≤—ñ—á–∫–∞ ~{minutes_left:.1f} —Ö–≤")
                
                return new_candles
                
            else:
                self.logger.error(f"‚ùå {combination['symbol']} {combination['timeframe']}: OANDA API –ø–æ–º–∏–ª–∫–∞ {response.status_code}")
                return []
                
        except Exception as e:
            self.logger.error(f"‚ùå {combination['symbol']} {combination['timeframe']}: –ø–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è - {e}")
            return []
    
    def prepare_candle_data(self, candles: List[Dict], combination: Dict) -> List[tuple]:
        """–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö —Å–≤–µ—á–µ–π –¥–ª—è –≤—Å—Ç–∞–≤–∫–∏ –≤ –ë–î"""
        prepared_data = []
        
        for candle in candles:
            try:
                timestamp = self.parse_oanda_time(candle['time'])
                
                mid_data = candle.get('mid', {})
                open_price = float(mid_data.get('o', 0))
                high_price = float(mid_data.get('h', 0))
                low_price = float(mid_data.get('l', 0))
                close_price = float(mid_data.get('c', 0))
                volume = int(candle.get('volume', 0))
                
                record = (
                    combination['symbol_id'],
                    combination['timeframe_id'],
                    timestamp,
                    open_price,
                    high_price,
                    low_price,
                    close_price,
                    volume
                )
                
                prepared_data.append(record)
                
            except Exception as e:
                self.logger.error(f"‚ùå {combination['symbol']} {combination['timeframe']}: –ø–æ–º–∏–ª–∫–∞ –æ–±—Ä–æ–±–∫–∏ —Å–≤—ñ—á–∫–∏ - {e}")
                continue
        
        return prepared_data
    
    def insert_candles_to_db(self, candle_data: List[tuple], combination: Dict) -> bool:
        """–í—Å—Ç–∞–≤–∫–∞ –Ω–æ–≤—ã—Ö —Å–≤–µ—á–µ–π –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –ø–∞—Ä—ã/—Ç–∞–π–º—Ñ—Ä–µ–π–º–∞"""
        if not candle_data:
            self.logger.debug(f"üíæ {combination['symbol']} {combination['timeframe']}: –Ω–µ–º–∞—î –¥–∞–Ω–∏—Ö –¥–ª—è –≤—Å—Ç–∞–≤–∫–∏")
            return True
        
        try:
            cursor = self.db_connection.cursor()
            
            # –õ–æ–≥–∏—Ä—É–µ–º —á—Ç–æ –∏–º–µ–Ω–Ω–æ –ø—ã—Ç–∞–µ–º—Å—è –≤—Å—Ç–∞–≤–∏—Ç—å
            if candle_data:
                first_timestamp = candle_data[0][2]  # timestamp is 3rd element
                last_timestamp = candle_data[-1][2]
                self.logger.debug(f"üíæ {combination['symbol']} {combination['timeframe']}: —Å–ø—Ä–æ–±–∞ –≤—Å—Ç–∞–≤–∫–∏ {len(candle_data)} —Å–≤—ñ—á–æ–∫ –≤—ñ–¥ {first_timestamp.strftime('%Y-%m-%d %H:%M:%S')} –¥–æ {last_timestamp.strftime('%Y-%m-%d %H:%M:%S')} UTC")
            
            insert_query = """
                INSERT INTO market_data.candles 
                (symbol_id, timeframe_id, timestamp, open, high, low, close, volume)
                VALUES %s
                ON CONFLICT (symbol_id, timeframe_id, timestamp) DO NOTHING
            """
            
            execute_values(cursor, insert_query, candle_data, page_size=100)
            
            # –ü–æ–ª—É—á–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ–∞–ª—å–Ω–æ –≤—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã—Ö –∑–∞–ø–∏—Å–µ–π
            inserted_count = cursor.rowcount
            
            self.db_connection.commit()
            cursor.close()
            
            if inserted_count > 0:
                self.logger.info(f"‚úÖ {combination['symbol']} {combination['timeframe']}: –≤—Å—Ç–∞–≤–ª–µ–Ω–æ {inserted_count} —Å–≤—ñ—á–æ–∫")
                
                # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
                pair_key = f"{combination['symbol']}_{combination['timeframe']}"
                if pair_key not in self.stats['pair_stats']:
                    self.stats['pair_stats'][pair_key] = {
                        'total_candles': 0,
                        'last_update': None,
                        'errors': 0
                    }
                
                self.stats['pair_stats'][pair_key]['total_candles'] += inserted_count
                self.stats['pair_stats'][pair_key]['last_update'] = datetime.utcnow()
            else:
                # –õ–æ–≥–∏—Ä—É–µ–º –¥–∞–∂–µ –∫–æ–≥–¥–∞ –Ω–∏—á–µ–≥–æ –Ω–µ –≤—Å—Ç–∞–≤–ª–µ–Ω–æ (–≤—Å–µ –¥—É–±–ª–∏)
                skipped_count = len(candle_data)
                self.logger.info(f"‚è≠Ô∏è {combination['symbol']} {combination['timeframe']}: {skipped_count} —Å–≤—ñ—á–æ–∫ –ø—Ä–æ–ø—É—â–µ–Ω–æ (–¥—É–±–ª—ñ –≤ –ë–î)")
                
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå {combination['symbol']} {combination['timeframe']}: –ø–æ–º–∏–ª–∫–∞ –≤—Å—Ç–∞–≤–∫–∏ –≤ –ë–î - {e}")
            self.db_connection.rollback()
            
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –æ—à–∏–±–æ–∫
            pair_key = f"{combination['symbol']}_{combination['timeframe']}"
            if pair_key not in self.stats['pair_stats']:
                self.stats['pair_stats'][pair_key] = {'total_candles': 0, 'last_update': None, 'errors': 0}
            self.stats['pair_stats'][pair_key]['errors'] += 1
            
            return False
    
    def update_single_combination(self, combination: Dict) -> bool:
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–¥–Ω–æ–π –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ –ø–∞—Ä—ã/—Ç–∞–π–º—Ñ—Ä–µ–π–º–∞"""
        try:
            self.logger.info(f"üîÑ –û–Ω–æ–≤–ª–µ–Ω–Ω—è {combination['symbol']} {combination['timeframe']}...")
            
            # –ü–æ–ª—É—á–∞–µ–º –≤—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–π —Å–≤–µ—á–∏
            last_candle_time = self.get_last_candle_time(combination)
            
            if last_candle_time is None:
                # –ï—Å–ª–∏ –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö, –Ω–∞—á–∏–Ω–∞–µ–º —Å 24 —á–∞—Å–æ–≤ –Ω–∞–∑–∞–¥
                from datetime import timezone
                last_candle_time = (datetime.utcnow() - timedelta(hours=24)).replace(tzinfo=timezone.utc)
                self.logger.warning(f"‚ö†Ô∏è {combination['symbol']} {combination['timeframe']}: –ø–æ—á–∏–Ω–∞—î–º–æ –∑ 24 –≥–æ–¥–∏–Ω —Ç–æ–º—É")
                request_from_time = last_candle_time
            else:
                # –ï—Å–ª–∏ –µ—Å—Ç—å –¥–∞–Ω–Ω—ã–µ, –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –Ω–∞—á–∏–Ω–∞—è —Å –ø–æ—Å–ª–µ–¥–Ω–µ–π —Å–≤–µ—á–∏
                request_from_time = last_candle_time
                self.logger.info(f"üîç {combination['symbol']} {combination['timeframe']}: –æ—Å—Ç–∞–Ω–Ω—è —Å–≤—ñ—á–∫–∞ –≤ –ë–î {last_candle_time.strftime('%Y-%m-%d %H:%M:%S')} UTC")
            
            # –ó–∞–≥—Ä—É–∂–∞–µ–º –Ω–æ–≤—ã–µ —Å–≤–µ—á–∏
            new_candles = self.fetch_new_candles(request_from_time, combination, last_candle_time)
            
            if new_candles:
                # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –∏ –≤—Å—Ç–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ
                prepared_data = self.prepare_candle_data(new_candles, combination)
                success = self.insert_candles_to_db(prepared_data, combination)
                self.logger.debug(f"üíæ {combination['symbol']} {combination['timeframe']}: –ø—ñ–¥–≥–æ—Ç–æ–≤–ª–µ–Ω–æ {len(prepared_data)} –∑–∞–ø–∏—Å—ñ–≤ –¥–ª—è –≤—Å—Ç–∞–≤–∫–∏")
                return success
            else:
                self.logger.debug(f"‚ÑπÔ∏è {combination['symbol']} {combination['timeframe']}: –Ω–æ–≤–∏—Ö —Å–≤—ñ—á–æ–∫ –Ω–µ–º–∞—î")
                return True
                
        except Exception as e:
            self.logger.error(f"‚ùå {combination['symbol']} {combination['timeframe']}: –ø–æ–º–∏–ª–∫–∞ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è - {e}")
            return False
    
    def update_all_combinations_sequential(self) -> Dict:
        """–ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—Å–µ—Ö –∫–æ–º–±–∏–Ω–∞—Ü–∏–π"""
        results = {
            'successful': 0,
            'failed': 0,
            'total_candles': 0,
            'details': []
        }
        
        for combination in self.combinations:
            try:
                success = self.update_single_combination(combination)
                
                if success:
                    results['successful'] += 1
                else:
                    results['failed'] += 1
                
                # –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –ø–∞—Ä–∞–º–∏
                if self.config['data_update'].get('stagger_delay', 0) > 0:
                    time.sleep(self.config['data_update']['stagger_delay'])
                
            except Exception as e:
                self.logger.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–Ω–∞ –ø–æ–º–∏–ª–∫–∞ –¥–ª—è {combination['symbol']} {combination['timeframe']}: {e}")
                results['failed'] += 1
        
        # –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–æ–≤—ã—Ö —Å–≤–µ—á–µ–π
        for pair_key, stats in self.stats['pair_stats'].items():
            if stats['last_update'] and (datetime.utcnow() - stats['last_update']).seconds < 300:  # –ó–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 5 –º–∏–Ω—É—Ç
                results['total_candles'] += stats.get('total_candles', 0)
        
        return results
    
    def update_all_combinations_parallel(self) -> Dict:
        """–ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—Å–µ—Ö –∫–æ–º–±–∏–Ω–∞—Ü–∏–π"""
        results = {
            'successful': 0,
            'failed': 0,
            'total_candles': 0,
            'details': []
        }
        
        max_workers = min(
            self.config['data_update'].get('max_workers', 3),
            len(self.combinations)
        )
        
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            # –ó–∞–ø—É—Å–∫–∞–µ–º –∑–∞–¥–∞—á–∏
            future_to_combination = {
                executor.submit(self.update_single_combination, combination): combination
                for combination in self.combinations
            }
            
            # –°–æ–±–∏—Ä–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
            completed = 0
            total = len(self.combinations)
            for future in as_completed(future_to_combination):
                combination = future_to_combination[future]
                completed += 1
                
                try:
                    success = future.result()
                    if success:
                        results['successful'] += 1
                    else:
                        results['failed'] += 1
                    
                    # –õ–æ–≥–∏—Ä—É–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –∫–∞–∂–¥—ã–µ 10 –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã—Ö –∑–∞–¥–∞—á
                    if completed % 10 == 0 or completed == total:
                        self.logger.info(f"üìä –ü—Ä–æ–≥—Ä–µ—Å: {completed}/{total} –∫–æ–º–±—ñ–Ω–∞—Ü—ñ–π –∑–∞–≤–µ—Ä—à–µ–Ω–æ")
                        
                except Exception as e:
                    self.logger.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ –≤ –ø–æ—Ç–æ—Ü—ñ –¥–ª—è {combination['symbol']} {combination['timeframe']}: {e}")
                    results['failed'] += 1
        
        return results
    
    def update_cycle(self):
        """–û–¥–∏–Ω —Ü–∏–∫–ª –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –≤—Å–µ—Ö –ø–∞—Ä –∏ —Ç–∞–π–º—Ñ—Ä–µ–π–º–æ–≤"""
        try:
            self.stats['total_updates'] += 1
            cycle_start_time = datetime.utcnow()
            
            self.logger.info(f"üîÑ –ü–æ—á–∞—Ç–æ–∫ —Ü–∏–∫–ª—É –æ–Ω–æ–≤–ª–µ–Ω–Ω—è #{self.stats['total_updates']}")
            
            # –í—ã–±–∏—Ä–∞–µ–º –º–µ—Ç–æ–¥ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è: –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–π –∏–ª–∏ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã–π
            if self.config['data_update'].get('parallel_downloads', True):
                max_workers = min(
                    self.config['data_update'].get('max_workers', 3),
                    len(self.combinations)
                )
                self.logger.info(f"üîÑ –ü–∞—Ä–∞–ª–µ–ª—å–Ω–µ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è: {len(self.combinations)} –∫–æ–º–±—ñ–Ω–∞—Ü—ñ–π, {max_workers} –ø–æ—Ç–æ–∫—ñ–≤")
                results = self.update_all_combinations_parallel()
            else:
                self.logger.info(f"üîÑ –ü–æ—Å–ª—ñ–¥–æ–≤–Ω–µ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è: {len(self.combinations)} –∫–æ–º–±—ñ–Ω–∞—Ü—ñ–π")
                results = self.update_all_combinations_sequential()
            
            cycle_duration = (datetime.utcnow() - cycle_start_time).total_seconds()
            
            # –û–±–Ω–æ–≤–ª—è–µ–º –æ–±—â—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            if results['failed'] == 0:
                self.stats['successful_updates'] += 1
            else:
                self.stats['failed_updates'] += 1
            
            self.stats['last_update_time'] = datetime.utcnow()
            
            # –õ–æ–≥–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
            self.logger.info(
                f"‚úÖ –¶–∏–∫–ª #{self.stats['total_updates']} –∑–∞–≤–µ—Ä—à–µ–Ω–æ –∑–∞ {cycle_duration:.1f}—Å: "
                f"—É—Å–ø—ñ—à–Ω–æ={results['successful']}, –ø–æ–º–∏–ª–æ–∫={results['failed']}, "
                f"–Ω–æ–≤–∏—Ö —Å–≤—ñ—á–æ–∫={results['total_candles']}"
            )
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤ Telegram –ø—Ä–∏ –Ω–∞–ª–∏—á–∏–∏ –Ω–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö
            if results['total_candles'] > 0:
                self.send_update_notification(results, cycle_duration)
            
            return results['failed'] == 0
            
        except Exception as e:
            self.logger.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–Ω–∞ –ø–æ–º–∏–ª–∫–∞ —Ü–∏–∫–ª—É –æ–Ω–æ–≤–ª–µ–Ω–Ω—è: {e}")
            self.telegram.send_message(
                f"‚ùå <b>–ö—Ä–∏—Ç–∏—á–Ω–∞ –ø–æ–º–∏–ª–∫–∞ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è</b>\n{str(e)[:200]}", 
                'system'
            )
            return False
    
    def send_update_notification(self, results: Dict, cycle_duration: float):
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ–± –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö"""
        try:
            # –§–æ—Ä–º–∏—Ä—É–µ–º –¥–µ—Ç–∞–ª—å–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ –ø–∞—Ä–∞–º
            active_pairs = []
            for pair_key, stats in self.stats['pair_stats'].items():
                if (stats['last_update'] and 
                    (datetime.utcnow() - stats['last_update']).seconds < 300):  # –ó–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 5 –º–∏–Ω—É—Ç
                    if stats.get('total_candles', 0) > 0:
                        active_pairs.append({
                            'name': pair_key.replace('_', ' '),
                            'candles': stats['total_candles']
                        })
            
            if active_pairs:
                pairs_text = "\n".join([f"üìà {pair['name']}: {pair['candles']} —Å–≤—ñ—á–æ–∫" 
                                       for pair in active_pairs[:5]])  # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–µ—Ä–≤—ã–µ 5
                
                if len(active_pairs) > 5:
                    pairs_text += f"\n... —Ç–∞ —â–µ {len(active_pairs) - 5} –ø–∞—Ä"
                
                message = (
                    f"üìä <b>–û–Ω–æ–≤–ª–µ–Ω–Ω—è –¥–∞–Ω–∏—Ö</b>\n"
                    f"üïê {datetime.utcnow().strftime('%H:%M:%S')} UTC\n"
                    f"‚è±Ô∏è –¢—Ä–∏–≤–∞–ª—ñ—Å—Ç—å: {cycle_duration:.1f}—Å\n"
                    f"‚úÖ –£—Å–ø—ñ—à–Ω–æ: {results['successful']}/{len(self.combinations)}\n"
                    f"üìà –í—Å—å–æ–≥–æ –Ω–æ–≤–∏—Ö —Å–≤—ñ—á–æ–∫: {results['total_candles']}\n\n"
                    f"{pairs_text}"
                )
                
                self.telegram.send_message(message, 'system')
        
        except Exception as e:
            self.logger.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–Ω—è: {e}")
    
    def send_heartbeat(self):
        """–û—Ç–ø—Ä–∞–≤–∫–∞ heartbeat —Å–æ–æ–±—â–µ–Ω–∏—è"""
        try:
            uptime = datetime.utcnow() - self.stats['start_time']
            uptime_str = str(uptime).split('.')[0]  # –£–±–∏—Ä–∞–µ–º –º–∏–∫—Ä–æ—Å–µ–∫—É–Ω–¥—ã
            
            # –°—á–∏—Ç–∞–µ–º –æ–±—â—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            total_candles = sum(stats.get('total_candles', 0) 
                               for stats in self.stats['pair_stats'].values())
            
            total_errors = sum(stats.get('errors', 0) 
                              for stats in self.stats['pair_stats'].values())
            
            message = (
                f"üíö <b>–°–∏—Å—Ç–µ–º–∞ –ø—Ä–∞—Ü—é—î</b>\n"
                f"üïê {datetime.utcnow().strftime('%H:%M:%S')} UTC\n"
                f"‚è∞ –ß–∞—Å —Ä–æ–±–æ—Ç–∏: {uptime_str}\n"
                f"üîÑ –¶–∏–∫–ª—ñ–≤ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è: {self.stats['total_updates']}\n"
                f"üìà –ê–∫—Ç–∏–≤–Ω–∏—Ö –ø–∞—Ä: {len(get_enabled_pairs())}\n"
                f"üìä –¢–∞–π–º—Ñ—Ä–µ–π–º—ñ–≤: {len(self.config['active_timeframes'])}\n"
                f"üíæ –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ —Å–≤—ñ—á–æ–∫: {total_candles}\n"
                f"‚ùå –ü–æ–º–∏–ª–æ–∫: {total_errors}"
            )
            
            self.telegram.send_message(message, 'system')
            
        except Exception as e:
            self.logger.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ heartbeat: {e}")
    
    def get_active_timeframes_now(self) -> List[str]:
        """–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ç–∞–π–º—Ñ—Ä–µ–π–º–æ–≤ –≤ —Ç–µ–∫—É—â–∏–π –º–æ–º–µ–Ω—Ç –≤—Ä–µ–º–µ–Ω–∏"""
        from datetime import timezone
        now = datetime.utcnow().replace(tzinfo=timezone.utc)
        
        active_timeframes = []
        schedules = self.config['data_update']['timeframe_schedules']
        target_second = self.config['data_update']['schedule_second']
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–µ–∫—É—â—É—é —Å–µ–∫—É–Ω–¥—É
        if now.second != target_second:
            self.logger.debug(f"‚è∞ –ü–æ—Ç–æ—á–Ω–∏–π —á–∞—Å: {now.strftime('%H:%M:%S')} UTC, –ø–æ—Ç—Ä—ñ–±–Ω–∞ —Å–µ–∫—É–Ω–¥–∞: {target_second}, –∞–∫—Ç–∏–≤–Ω–∏—Ö —Ç–∞–π–º—Ñ—Ä–µ–π–º—ñ–≤: 0")
            return active_timeframes
            
        current_minute = now.minute
        current_hour = now.hour
        
        for tf_name, schedule in schedules.items():
            if not schedule.get('enabled', True):
                continue
                
            interval_minutes = schedule['interval_minutes']
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥—Ö–æ–¥–∏—Ç –ª–∏ —Ç–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è –¥–ª—è –¥–∞–Ω–Ω–æ–≥–æ —Ç–∞–π–º—Ñ—Ä–µ–π–º–∞
            if interval_minutes >= 1440:  # D1 - –µ–∂–µ–¥–Ω–µ–≤–Ω–æ –≤ 00:02
                if current_hour == 0 and current_minute == 0:
                    active_timeframes.append(tf_name)
            elif interval_minutes >= 60:  # H1, H4 - –∫–∞–∂–¥—ã–µ N —á–∞—Å–æ–≤ –≤ :02
                hours_interval = interval_minutes // 60
                if current_hour % hours_interval == 0 and current_minute == 0:
                    active_timeframes.append(tf_name)
            else:  # M5, M15, M30 - –∫–∞–∂–¥—ã–µ N –º–∏–Ω—É—Ç –≤ :02
                if current_minute % interval_minutes == 0:
                    active_timeframes.append(tf_name)
        
        self.logger.info(f"‚è∞ –ü–æ—Ç–æ—á–Ω–∏–π —á–∞—Å: {now.strftime('%H:%M:%S')} UTC, –∞–∫—Ç–∏–≤–Ω—ñ —Ç–∞–π–º—Ñ—Ä–µ–π–º–∏: {', '.join(active_timeframes) if active_timeframes else '–Ω–µ–º–∞—î'}")
        return active_timeframes
    
    def calculate_seconds_until_next_schedule(self) -> int:
        """–í—ã—á–∏—Å–ª–µ–Ω–∏–µ —Å–µ–∫—É–Ω–¥ –¥–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏"""
        from datetime import timezone
        now = datetime.utcnow().replace(tzinfo=timezone.utc)
        
        schedules = self.config['data_update']['timeframe_schedules']
        target_second = self.config['data_update']['schedule_second']
        
        next_times = []
        
        for tf_name, schedule in schedules.items():
            if not schedule.get('enabled', True):
                continue
                
            interval_minutes = schedule['interval_minutes']
            
            # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Å–ª–µ–¥—É—é—â–µ–µ –≤—Ä–µ–º—è –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ç–∞–π–º—Ñ—Ä–µ–π–º–∞
            if interval_minutes >= 1440:  # D1 - —Å–ª–µ–¥—É—é—â–∏–π –¥–µ–Ω—å –≤ 00:02
                next_time = now.replace(hour=0, minute=0, second=target_second, microsecond=0)
                if next_time <= now:
                    next_time += timedelta(days=1)
                next_times.append(next_time)
                
            elif interval_minutes >= 60:  # H1, H4 - —Å–ª–µ–¥—É—é—â–∏–π –ø–æ–¥—Ö–æ–¥—è—â–∏–π —á–∞—Å
                hours_interval = interval_minutes // 60
                next_hour = ((now.hour // hours_interval) + 1) * hours_interval
                if next_hour >= 24:
                    next_hour = 0
                    next_time = now.replace(hour=next_hour, minute=0, second=target_second, microsecond=0) + timedelta(days=1)
                else:
                    next_time = now.replace(hour=next_hour, minute=0, second=target_second, microsecond=0)
                next_times.append(next_time)
                
            else:  # M5, M15, M30 - —Å–ª–µ–¥—É—é—â–∞—è –ø–æ–¥—Ö–æ–¥—è—â–∞—è –º–∏–Ω—É—Ç–∞
                next_minute = ((now.minute // interval_minutes) + 1) * interval_minutes
                if next_minute >= 60:
                    next_minute = 0
                    next_hour = now.hour + 1
                    if next_hour >= 24:
                        next_hour = 0
                        next_time = now.replace(hour=next_hour, minute=next_minute, second=target_second, microsecond=0) + timedelta(days=1)
                    else:
                        next_time = now.replace(hour=next_hour, minute=next_minute, second=target_second, microsecond=0)
                else:
                    next_time = now.replace(minute=next_minute, second=target_second, microsecond=0)
                next_times.append(next_time)
        
        # –ù–∞—Ö–æ–¥–∏–º –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è
        if not next_times:
            # –ï—Å–ª–∏ –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–π, –∂–¥–µ–º –¥–æ —Å–ª–µ–¥—É—é—â–µ–π –º–∏–Ω—É—Ç—ã
            next_time = now.replace(second=target_second, microsecond=0) + timedelta(minutes=1)
        else:
            next_time = min(next_times)
        
        seconds_until = (next_time - now).total_seconds()
        
        self.logger.info(f"‚è∞ –ù–∞—Å—Ç—É–ø–Ω–µ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è: {next_time.strftime('%H:%M:%S')} UTC (—á–µ—Ä–µ–∑ {seconds_until:.0f} —Å–µ–∫—É–Ω–¥)")
        return max(1, int(seconds_until))
    
    def initial_history_download(self):
        """–ü–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω–∞—è –¥–æ–∫–∞—á–∫–∞ –∏—Å—Ç–æ—Ä–∏–∏ –¥–ª—è –≤—Å–µ—Ö –ø–∞—Ä –∏ —Ç–∞–π–º—Ñ—Ä–µ–π–º–æ–≤"""
        if not self.config['data_update'].get('initial_history_download', True):
            self.logger.info("‚è∏Ô∏è –ü–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω–∞ –¥–æ–∫–∞—á–∫–∞ –≤–∏–º–∫–Ω–µ–Ω–∞ –≤ –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—ó")
            return
        
        self.logger.info("üîÑ –ü–æ—á–∞—Ç–æ–∫ –ø–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω–æ—ó –¥–æ–∫–∞—á–∫–∏ —ñ—Å—Ç–æ—Ä—ñ—ó...")
        
        history_days = self.config['data_update'].get('history_download_days', 30)
        from datetime import timezone
        start_date = datetime.utcnow().replace(tzinfo=timezone.utc) - timedelta(days=history_days)
        
        total_combinations = len(self.combinations)
        successful_downloads = 0
        failed_downloads = 0
        
        # –ú–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –∏—Å—Ç–æ—Ä–∏–∏
        if self.config['data_update'].get('parallel_downloads', True):
            max_workers = min(
                self.config['data_update'].get('max_workers', 7),
                len(self.combinations)
            )
            
            self.logger.info(f"üîÑ –ë–∞–≥–∞—Ç–æ–ø–æ—Ç–æ–∫–æ–≤–∞ –¥–æ–∫–∞—á–∫–∞ —ñ—Å—Ç–æ—Ä—ñ—ó: {max_workers} –ø–æ—Ç–æ–∫—ñ–≤")
            
            with ThreadPoolExecutor(max_workers=max_workers) as executor:
                future_to_combination = {
                    executor.submit(self.download_history_for_combination, combination, start_date): combination
                    for combination in self.combinations
                }
                
                for i, future in enumerate(as_completed(future_to_combination), 1):
                    combination = future_to_combination[future]
                    try:
                        success = future.result()
                        if success:
                            successful_downloads += 1
                        else:
                            failed_downloads += 1
                            
                        self.logger.info(f"üìä –ü—Ä–æ–≥—Ä–µ—Å –¥–æ–∫–∞—á–∫–∏: {i}/{total_combinations} –∑–∞–≤–µ—Ä—à–µ–Ω–æ")
                        
                    except Exception as e:
                        self.logger.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ –≤ –ø–æ—Ç–æ—Ü—ñ –¥–ª—è {combination['symbol']} {combination['timeframe']}: {e}")
                        failed_downloads += 1
        else:
            # –ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –∏—Å—Ç–æ—Ä–∏–∏
            self.logger.info(f"üîÑ –ü–æ—Å–ª—ñ–¥–æ–≤–Ω–∞ –¥–æ–∫–∞—á–∫–∞ —ñ—Å—Ç–æ—Ä—ñ—ó")
            
            for i, combination in enumerate(self.combinations, 1):
                try:
                    self.logger.info(f"üì• –î–æ–∫–∞—á–∫–∞ —ñ—Å—Ç–æ—Ä—ñ—ó {i}/{total_combinations}: {combination['symbol']} {combination['timeframe']}")
                    success = self.download_history_for_combination(combination, start_date)
                    
                    if success:
                        successful_downloads += 1
                    else:
                        failed_downloads += 1
                        
                except Exception as e:
                    self.logger.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ –¥–æ–∫–∞—á–∫–∏ –¥–ª—è {combination['symbol']} {combination['timeframe']}: {e}")
                    failed_downloads += 1
        
        self.logger.info(f"‚úÖ –ü–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω–∞ –¥–æ–∫–∞—á–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞: —É—Å–ø—ñ—à–Ω–æ={successful_downloads}, –ø–æ–º–∏–ª–æ–∫={failed_downloads}")
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ –¥–æ–∫–∞—á–∫–∏
        message = (
            f"üìä <b>–ü–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω–∞ –¥–æ–∫–∞—á–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞</b>\n"
            f"üïê {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')} UTC\n"
            f"‚úÖ –£—Å–ø—ñ—à–Ω–æ: {successful_downloads}\n"
            f"‚ùå –ü–æ–º–∏–ª–æ–∫: {failed_downloads}\n"
            f"üìà –í—Å—å–æ–≥–æ –∫–æ–º–±—ñ–Ω–∞—Ü—ñ–π: {total_combinations}\n"
            f"‚è∞ –Ü—Å—Ç–æ—Ä—ñ—è: {history_days} –¥–Ω—ñ–≤"
        )
        
        self.telegram.send_message(message, 'system')
    
    def download_history_for_combination(self, combination: Dict, start_date: datetime) -> bool:
        """–ó–∞–≥—Ä—É–∑–∫–∞ –∏—Å—Ç–æ—Ä–∏–∏ –¥–ª—è –æ–¥–Ω–æ–π –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ –ø–∞—Ä—ã/—Ç–∞–π–º—Ñ—Ä–µ–π–º–∞"""
        try:
            self.logger.info(f"üì• –î–æ–∫–∞—á–∫–∞ —ñ—Å—Ç–æ—Ä—ñ—ó: {combination['symbol']} {combination['timeframe']}")
            
            # –ü–æ–ª—É—á–∞–µ–º –≤—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–π —Å–≤–µ—á–∏
            last_candle_time = self.get_last_candle_time(combination)
            
            if last_candle_time is None:
                # –ï—Å–ª–∏ –¥–∞–Ω–Ω—ã—Ö –Ω–µ—Ç, –∫–∞—á–∞–µ–º —Å start_date
                download_from = start_date
                self.logger.info(f"üìä {combination['symbol']} {combination['timeframe']}: –Ω–µ–º–∞—î –¥–∞–Ω–∏—Ö, –∑–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ –∑ {start_date.strftime('%Y-%m-%d %H:%M:%S')} UTC")
            elif last_candle_time < start_date:
                # –ï—Å–ª–∏ –¥–∞–Ω–Ω—ã–µ —Å—Ç–∞—Ä—ã–µ, –∫–∞—á–∞–µ–º —Å start_date
                download_from = start_date
                self.logger.info(f"üìä {combination['symbol']} {combination['timeframe']}: —Å—Ç–∞—Ä—ñ –¥–∞–Ω—ñ, –∑–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ –∑ {start_date.strftime('%Y-%m-%d %H:%M:%S')} UTC")
            else:
                # –ï—Å–ª–∏ –¥–∞–Ω–Ω—ã–µ —Å–≤–µ–∂–∏–µ, –∫–∞—á–∞–µ–º —Å –ø–æ—Å–ª–µ–¥–Ω–µ–π —Å–≤–µ—á–∏
                download_from = last_candle_time
                self.logger.info(f"üìä {combination['symbol']} {combination['timeframe']}: —Å–≤—ñ–∂—ñ –¥–∞–Ω—ñ, –∑–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ –∑ {last_candle_time.strftime('%Y-%m-%d %H:%M:%S')} UTC")
            
            # –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ—Ä—Ü–∏—è–º–∏
            from datetime import timezone
            current_date = download_from
            end_date = datetime.utcnow().replace(tzinfo=timezone.utc)
            total_loaded = 0
            
            while current_date < end_date:
                # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ä–∞–∑–º–µ—Ä –ø–æ—Ä—Ü–∏–∏ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∞–π–º—Ñ—Ä–µ–π–º–∞
                if combination['timeframe'] == 'M5':
                    chunk_days = 7  # 7 –¥–Ω–µ–π –¥–ª—è M5
                elif combination['timeframe'] == 'M15':
                    chunk_days = 15  # 15 –¥–Ω–µ–π –¥–ª—è M15
                elif combination['timeframe'] == 'M30':
                    chunk_days = 30  # 30 –¥–Ω–µ–π –¥–ª—è M30
                elif combination['timeframe'] == 'H1':
                    chunk_days = 60  # 60 –¥–Ω–µ–π –¥–ª—è H1
                elif combination['timeframe'] == 'H4':
                    chunk_days = 120  # 120 –¥–Ω–µ–π –¥–ª—è H4
                elif combination['timeframe'] == 'D1':
                    chunk_days = 365  # 365 –¥–Ω–µ–π –¥–ª—è D1
                else:
                    chunk_days = 30  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é
                
                chunk_end = min(current_date + timedelta(days=chunk_days), end_date)
                
                # –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–æ—Ä—Ü–∏—é (–±–µ–∑ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –¥–ª—è –∏—Å—Ç–æ—Ä–∏–∏)
                new_candles = self.fetch_new_candles(current_date, combination, None, chunk_end)
                
                if new_candles:
                    # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –∏ –≤—Å—Ç–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ
                    prepared_data = self.prepare_candle_data(new_candles, combination)
                    self.insert_candles_to_db(prepared_data, combination)
                    total_loaded += len(new_candles)
                
                current_date = chunk_end
                
                # –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏ –¥–ª—è —Å–æ–±–ª—é–¥–µ–Ω–∏—è –ª–∏–º–∏—Ç–æ–≤ API
                time.sleep(self.config['oanda']['rate_limit_delay'])
            
            if total_loaded > 0:
                self.logger.info(f"‚úÖ {combination['symbol']} {combination['timeframe']}: –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ {total_loaded} —Å–≤—ñ—á–æ–∫")
            else:
                self.logger.debug(f"‚ÑπÔ∏è {combination['symbol']} {combination['timeframe']}: –Ω–µ–º–∞—î –Ω–æ–≤–∏—Ö –¥–∞–Ω–∏—Ö")
            
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ –¥–æ–∫–∞—á–∫–∏ –¥–ª—è {combination['symbol']} {combination['timeframe']}: {e}")
            return False
    
    def group_combinations_by_timeframes(self, active_timeframes: List[str]) -> Dict[str, List[Dict]]:
        """–ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –∫–æ–º–±–∏–Ω–∞—Ü–∏–π –ø–æ –∞–∫—Ç–∏–≤–Ω—ã–º —Ç–∞–π–º—Ñ—Ä–µ–π–º–∞–º"""
        grouped = {}
        all_pairs = get_all_pairs()
        
        for tf_name in active_timeframes:
            # –ù–∞—Ö–æ–¥–∏–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é —Ç–∞–π–º—Ñ—Ä–µ–π–º–∞
            tf_config = get_timeframe_by_name(tf_name)
            if not tf_config:
                continue
                
            combinations = []
            for pair in all_pairs:
                combinations.append({
                    'symbol': pair['symbol'],
                    'symbol_id': pair['symbol_id'],
                    'timeframe': tf_name,
                    'timeframe_id': tf_config['id'],
                    'oanda_format': tf_config['oanda_format'],
                    'priority': pair['priority'],
                    'enabled': pair['enabled'],
                    'description': f"{pair['description']} {tf_config['description']}"
                })
            
            grouped[tf_name] = combinations
            
        return grouped
    
    def update_timeframe_group(self, timeframe: str, combinations: List[Dict]) -> Dict:
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –≥—Ä—É–ø–ø—ã –ø–∞—Ä –æ–¥–Ω–æ–≥–æ —Ç–∞–π–º—Ñ—Ä–µ–π–º–∞"""
        self.logger.info(f"üîÑ –û–Ω–æ–≤–ª–µ–Ω–Ω—è —Ç–∞–π–º—Ñ—Ä–µ–π–º—É {timeframe}: {len(combinations)} –ø–∞—Ä")
        
        results = {
            'timeframe': timeframe,
            'successful': 0,
            'failed': 0,
            'total_candles': 0,
            'details': []
        }
        
        if self.config['data_update'].get('parallel_downloads', True):
            # –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–∞—Ä –≤ —Ç–∞–π–º—Ñ—Ä–µ–π–º–µ
            max_workers = min(
                self.config['data_update'].get('max_workers', 7),
                len(combinations)
            )
            
            with ThreadPoolExecutor(max_workers=max_workers) as executor:
                future_to_combination = {
                    executor.submit(self.update_single_combination, combination): combination
                    for combination in combinations
                }
                
                for future in as_completed(future_to_combination):
                    combination = future_to_combination[future]
                    try:
                        success = future.result()
                        if success:
                            results['successful'] += 1
                        else:
                            results['failed'] += 1
                            
                    except Exception as e:
                        self.logger.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ –≤ –ø–æ—Ç–æ—Ü—ñ –¥–ª—è {combination['symbol']} {combination['timeframe']}: {e}")
                        results['failed'] += 1
        else:
            # –ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–∞—Ä –≤ —Ç–∞–π–º—Ñ—Ä–µ–π–º–µ
            for combination in combinations:
                try:
                    success = self.update_single_combination(combination)
                    if success:
                        results['successful'] += 1
                    else:
                        results['failed'] += 1
                    
                    # –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –ø–∞—Ä–∞–º–∏
                    if self.config['data_update'].get('stagger_delay', 0) > 0:
                        time.sleep(self.config['data_update']['stagger_delay'])
                        
                except Exception as e:
                    self.logger.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–Ω–∞ –ø–æ–º–∏–ª–∫–∞ –¥–ª—è {combination['symbol']} {combination['timeframe']}: {e}")
                    results['failed'] += 1
        
        # –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º –Ω–æ–≤—ã–µ —Å–≤–µ—á–∏ –¥–ª—è —ç—Ç–æ–≥–æ —Ç–∞–π–º—Ñ—Ä–µ–π–º–∞
        for pair_key, stats in self.stats['pair_stats'].items():
            if (timeframe in pair_key and stats['last_update'] and 
                (datetime.utcnow() - stats['last_update']).seconds < 300):  # –ó–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 5 –º–∏–Ω—É—Ç
                results['total_candles'] += stats.get('total_candles', 0)
        
        self.logger.info(f"‚úÖ –¢–∞–π–º—Ñ—Ä–µ–π–º {timeframe}: —É—Å–ø—ñ—à–Ω–æ={results['successful']}, –ø–æ–º–∏–ª–æ–∫={results['failed']}, –Ω–æ–≤–∏—Ö —Å–≤—ñ—á–æ–∫={results['total_candles']}")
        return results
    
    def smart_update_cycle(self):
        """–£–º–Ω—ã–π —Ü–∏–∫–ª –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –ø–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—é —Ç–∞–π–º—Ñ—Ä–µ–π–º–æ–≤"""
        try:
            self.stats['total_updates'] += 1
            cycle_start_time = datetime.utcnow()
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∞–∫—Ç–∏–≤–Ω—ã–µ —Ç–∞–π–º—Ñ—Ä–µ–π–º—ã
            active_timeframes = self.get_active_timeframes_now()
            

            
            if not active_timeframes:
                self.logger.info("‚ÑπÔ∏è –ù–µ–º–∞—î –∞–∫—Ç–∏–≤–Ω–∏—Ö —Ç–∞–π–º—Ñ—Ä–µ–π–º—ñ–≤ –≤ –ø–æ—Ç–æ—á–Ω–∏–π –º–æ–º–µ–Ω—Ç")
                return True
            
            self.logger.info(f"üîÑ –†–æ–∑—É–º–Ω–∏–π —Ü–∏–∫–ª #{self.stats['total_updates']}: –∞–∫—Ç–∏–≤–Ω—ñ —Ç–∞–π–º—Ñ—Ä–µ–π–º–∏ {', '.join(active_timeframes)}")
            
            # –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ –ø–æ —Ç–∞–π–º—Ñ—Ä–µ–π–º–∞–º
            grouped_combinations = self.group_combinations_by_timeframes(active_timeframes)
            
            total_successful = 0
            total_failed = 0
            total_new_candles = 0
            timeframe_results = []
            
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–∂–¥—ã–π —Ç–∞–π–º—Ñ—Ä–µ–π–º
            for timeframe, combinations in grouped_combinations.items():
                if not combinations:
                    continue
                    
                try:
                    result = self.update_timeframe_group(timeframe, combinations)
                    timeframe_results.append(result)
                    
                    total_successful += result['successful']
                    total_failed += result['failed']
                    total_new_candles += result['total_candles']
                    
                    # –ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –≥—Ä—É–ø–ø–∞–º–∏ —Ç–∞–π–º—Ñ—Ä–µ–π–º–æ–≤
                    if (self.config['data_update'].get('batch_delay_between_groups', 0) > 0 and
                        timeframe != list(grouped_combinations.keys())[-1]):  # –ù–µ –ø–æ—Å–ª–µ–¥–Ω–∏–π
                        time.sleep(self.config['data_update']['batch_delay_between_groups'])
                        
                except Exception as e:
                    self.logger.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–Ω–∞ –ø–æ–º–∏–ª–∫–∞ –¥–ª—è —Ç–∞–π–º—Ñ—Ä–µ–π–º—É {timeframe}: {e}")
                    total_failed += len(combinations)
            
            cycle_duration = (datetime.utcnow() - cycle_start_time).total_seconds()
            
            # –û–±–Ω–æ–≤–ª—è–µ–º –æ–±—â—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            if total_failed == 0:
                self.stats['successful_updates'] += 1
            else:
                self.stats['failed_updates'] += 1
                
            self.stats['last_update_time'] = datetime.utcnow()
            
            # –õ–æ–≥–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
            tf_summary = ", ".join([f"{r['timeframe']}({r['successful']}/{len(grouped_combinations[r['timeframe']])})" 
                                   for r in timeframe_results])
            
            self.logger.info(
                f"‚úÖ –†–æ–∑—É–º–Ω–∏–π —Ü–∏–∫–ª #{self.stats['total_updates']} –∑–∞–≤–µ—Ä—à–µ–Ω–æ –∑–∞ {cycle_duration:.1f}—Å: "
                f"—Ç–∞–π–º—Ñ—Ä–µ–π–º–∏=[{tf_summary}], –Ω–æ–≤–∏—Ö —Å–≤—ñ—á–æ–∫={total_new_candles}"
            )
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤ Telegram –ø—Ä–∏ –Ω–∞–ª–∏—á–∏–∏ –Ω–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö
            if total_new_candles > 0:
                self.send_smart_update_notification(active_timeframes, timeframe_results, cycle_duration)
            
            return total_failed == 0
            
        except Exception as e:
            self.logger.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–Ω–∞ –ø–æ–º–∏–ª–∫–∞ —Ä–æ–∑—É–º–Ω–æ–≥–æ —Ü–∏–∫–ª—É –æ–Ω–æ–≤–ª–µ–Ω–Ω—è: {e}")
            self.telegram.send_message(
                f"‚ùå <b>–ö—Ä–∏—Ç–∏—á–Ω–∞ –ø–æ–º–∏–ª–∫–∞ —Ä–æ–∑—É–º–Ω–æ–≥–æ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è</b>\n{str(e)[:200]}", 
                'system'
            )
            return False
    
    def send_smart_update_notification(self, active_timeframes: List[str], timeframe_results: List[Dict], cycle_duration: float):
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ–± —É–º–Ω–æ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö"""
        try:
            tf_details = []
            total_candles = 0
            
            for result in timeframe_results:
                if result['total_candles'] > 0:
                    tf_details.append(f"üìä {result['timeframe']}: {result['total_candles']} —Å–≤—ñ—á–æ–∫ ({result['successful']}/{result['successful']+result['failed']} –ø–∞—Ä)")
                    total_candles += result['total_candles']
            
            if tf_details:
                message = (
                    f"üß† <b>–†–æ–∑—É–º–Ω–µ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è</b>\n"
                    f"üïê {datetime.utcnow().strftime('%H:%M:%S')} UTC\n"
                    f"‚è±Ô∏è –¢—Ä–∏–≤–∞–ª—ñ—Å—Ç—å: {cycle_duration:.1f}—Å\n"
                    f"üìà –ê–∫—Ç–∏–≤–Ω—ñ —Ç–∞–π–º—Ñ—Ä–µ–π–º–∏: {', '.join(active_timeframes)}\n"
                    f"üíæ –í—Å—å–æ–≥–æ –Ω–æ–≤–∏—Ö —Å–≤—ñ—á–æ–∫: {total_candles}\n\n"
                    f"{chr(10).join(tf_details)}"
                )
                
                self.telegram.send_message(message, 'system')
        
        except Exception as e:
            self.logger.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥–ø—Ä–∞–≤–∫–∏ —Ä–æ–∑—É–º–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–Ω—è: {e}")
    
    def run(self):
        """–û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª —Ä–∞–±–æ—Ç—ã –±–∞–≥–∞—Ç–æ–ø–∞—Ä–Ω–æ–≥–æ –∑–∞–≥—Ä—É–∑—á–∏–∫–∞"""
        self.logger.info("üöÄ –ó–∞–ø—É—Å–∫ –±–∞–≥–∞—Ç–æ–ø–∞—Ä–Ω–æ–≥–æ –∑–∞–≤–∞–Ω—Ç–∞–∂—É–≤–∞—á–∞ –¥–∞–Ω–∏—Ö")
        
        # –ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
        if not self.connect_to_database():
            return
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
        self.stats['start_time'] = datetime.utcnow()
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –∑–∞–ø—É—Å–∫–µ
        all_pairs = get_all_pairs()
        pairs_text = ", ".join([pair['symbol'] for pair in all_pairs])
        timeframes_text = ", ".join(self.config['active_timeframes'])
        
        smart_schedule_mode = self.config['data_update'].get('smart_schedule_mode', False)
        
        if smart_schedule_mode:
            active_schedules = []
            for tf, schedule in self.config['data_update']['timeframe_schedules'].items():
                if schedule.get('enabled', True):
                    active_schedules.append(f"{tf}(–∫–æ–∂–Ω—ñ {schedule['interval_minutes']}—Ö–≤)")
            schedule_text = f"–†–æ–∑—É–º–Ω–∏–π —Ä–µ–∂–∏–º: {', '.join(active_schedules)}"
        else:
            schedule_text = f"–Ü–Ω—Ç–µ—Ä–≤–∞–ª {self.config['data_update']['update_interval']}—Å"
        
        download_text = "–ü–∞—Ä–∞–ª–µ–ª—å–Ω–∏–π" if self.config['data_update'].get('parallel_downloads', True) else "–ü–æ—Å–ª—ñ–¥–æ–≤–Ω–∏–π"
        
        startup_message = (
            f"üöÄ <b>–ë–∞–≥–∞—Ç–æ–ø–∞—Ä–Ω–∏–π –∑–∞–≤–∞–Ω—Ç–∞–∂—É–≤–∞—á –∑–∞–ø—É—â–µ–Ω–æ</b>\n"
            f"üïê {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')} UTC\n"
            f"üí± –í–∞–ª—é—Ç–Ω—ñ –ø–∞—Ä–∏: {pairs_text}\n"
            f"üìä –¢–∞–π–º—Ñ—Ä–µ–π–º–∏: {timeframes_text}\n"
            f"üî¢ –ö–æ–º–±—ñ–Ω–∞—Ü—ñ–π: {len(self.combinations)}\n"
            f"‚è±Ô∏è –†–µ–∂–∏–º: {schedule_text}\n"
            f"üîÑ –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è: {download_text}"
        )
        
        self.telegram.send_message(startup_message, 'system')
        
        # –í—ã–ø–æ–ª–Ω—è–µ–º –ø–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω—É—é –¥–æ–∫–∞—á–∫—É –∏—Å—Ç–æ—Ä–∏–∏
        self.initial_history_download()
        
        # –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –∑–∞–ø—É—Å–∫–∞–µ–º –ø–µ—Ä–≤—ã–π —Ü–∏–∫–ª –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
        self.logger.info("üöÄ –ü—Ä–∏–º—É—Å–æ–≤–∏–π –∑–∞–ø—É—Å–∫ –ø–µ—Ä—à–æ–≥–æ —Ü–∏–∫–ª—É –æ–Ω–æ–≤–ª–µ–Ω–Ω—è...")
        self.update_cycle()
        
        self.running = True
        failed_attempts = 0
        max_retries = self.config['data_update']['max_retries']
        last_heartbeat = datetime.utcnow()
        heartbeat_interval = self.config['monitoring'].get('heartbeat_interval', 3600)  # 1 —á–∞—Å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        smart_schedule_mode = self.config['data_update'].get('smart_schedule_mode', False)
        
        while self.running:
            try:
                # –í—ã–±–∏—Ä–∞–µ–º —Ä–µ–∂–∏–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
                if smart_schedule_mode:
                    success = self.smart_update_cycle()
                else:
                    success = self.update_cycle()
                
                if success:
                    failed_attempts = 0
                else:
                    failed_attempts += 1
                    if failed_attempts >= max_retries:
                        self.logger.error(f"‚ùå –î–æ—Å—è–≥–Ω—É—Ç–æ –º–∞–∫—Å–∏–º—É–º –Ω–µ–≤–¥–∞–ª–∏—Ö —Å–ø—Ä–æ–± ({max_retries})")
                        self.telegram.send_message(
                            f"üõë <b>–ó–∞–≤–∞–Ω—Ç–∞–∂—É–≤–∞—á –∑—É–ø–∏–Ω–µ–Ω–æ</b>\n"
                            f"‚ùå –î–æ—Å—è–≥–Ω—É—Ç–æ –º–∞–∫—Å–∏–º—É–º –ø–æ–º–∏–ª–æ–∫: {max_retries}\n"
                            f"üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞: {self.stats['successful_updates']}/{self.stats['total_updates']} —É—Å–ø—ñ—à–Ω–∏—Ö —Ü–∏–∫–ª—ñ–≤", 
                            'system'
                        )
                        break
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω—É–∂–Ω–æ –ª–∏ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å heartbeat
                if (datetime.utcnow() - last_heartbeat).seconds >= heartbeat_interval:
                    self.send_heartbeat()
                    last_heartbeat = datetime.utcnow()
                
                # –°–ø–∏–º –¥–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
                if success:
                    if smart_schedule_mode:
                        # –í —É–º–Ω–æ–º —Ä–µ–∂–∏–º–µ –∂–¥–µ–º –¥–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏
                        wait_seconds = self.calculate_seconds_until_next_schedule()
                        self.logger.info(f"‚è≥ –û—á—ñ–∫—É–≤–∞–Ω–Ω—è {wait_seconds}—Å –¥–æ –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ —Ä–æ–∑–∫–ª–∞–¥—É...")
                        time.sleep(wait_seconds)
                    else:
                        # –í –æ–±—ã—á–Ω–æ–º —Ä–µ–∂–∏–º–µ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª
                        time.sleep(self.config['data_update']['update_interval'])
                else:
                    # –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –∏–Ω—Ç–µ—Ä–≤–∞–ª –ø—Ä–∏ –æ—à–∏–±–∫–∞—Ö
                    retry_delay = self.config['data_update']['retry_interval'] * min(failed_attempts, 5)
                    self.logger.warning(f"‚è≥ –ü–∞—É–∑–∞ {retry_delay}—Å –ø—ñ—Å–ª—è –ø–æ–º–∏–ª–∫–∏ (—Å–ø—Ä–æ–±–∞ {failed_attempts}/{max_retries})")
                    time.sleep(retry_delay)
                
            except KeyboardInterrupt:
                self.logger.info("‚èπÔ∏è –û—Ç—Ä–∏–º–∞–Ω–æ —Å–∏–≥–Ω–∞–ª –∑—É–ø–∏–Ω–∫–∏")
                break
            except Exception as e:
                self.logger.error(f"‚ùå –ù–µ–æ—á—ñ–∫—É–≤–∞–Ω–∞ –ø–æ–º–∏–ª–∫–∞: {e}")
                failed_attempts += 1
                time.sleep(self.config['data_update']['retry_interval'])
        
        self.running = False
        uptime = datetime.utcnow() - self.stats['start_time'] if self.stats['start_time'] else timedelta(0)
        
        self.logger.info(f"üõë –ó–∞–≤–∞–Ω—Ç–∞–∂—É–≤–∞—á –∑—É–ø–∏–Ω–µ–Ω–æ –ø—ñ—Å–ª—è {uptime}")
        
        # –ó–∞–∫—Ä—ã–≤–∞–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å –ë–î
        if self.db_connection:
            self.db_connection.close()
        
        # –§–∏–Ω–∞–ª—å–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        total_candles = sum(stats.get('total_candles', 0) for stats in self.stats['pair_stats'].values())
        total_errors = sum(stats.get('errors', 0) for stats in self.stats['pair_stats'].values())
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ–± –æ—Å—Ç–∞–Ω–æ–≤–∫–µ
        shutdown_message = (
            f"üõë <b>–ó–∞–≤–∞–Ω—Ç–∞–∂—É–≤–∞—á –∑—É–ø–∏–Ω–µ–Ω–æ</b>\n"
            f"üïê {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')} UTC\n"
            f"‚è∞ –ß–∞—Å —Ä–æ–±–æ—Ç–∏: {str(uptime).split('.')[0]}\n"
            f"üîÑ –¶–∏–∫–ª—ñ–≤: {self.stats['total_updates']}\n"
            f"‚úÖ –£—Å–ø—ñ—à–Ω–∏—Ö: {self.stats['successful_updates']}\n"
            f"üíæ –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ —Å–≤—ñ—á–æ–∫: {total_candles}\n"
            f"‚ùå –ü–æ–º–∏–ª–æ–∫: {total_errors}"
        )
        
        self.telegram.send_message(shutdown_message, 'system')

def main():
    """–ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è"""
    try:
        print("üöÄ –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –±–∞–≥–∞—Ç–æ–ø–∞—Ä–Ω–æ–≥–æ –∑–∞–≤–∞–Ω—Ç–∞–∂—É–≤–∞—á–∞ –¥–∞–Ω–∏—Ö...")
        updater = MultiPairDataUpdater()
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
        all_pairs = get_all_pairs()
        if not all_pairs:
            print("‚ùå –ü–æ–º–∏–ª–∫–∞: –ù–µ –Ω–∞–ª–∞—à—Ç–æ–≤–∞–Ω–æ –∂–æ–¥–Ω–æ—ó –≤–∞–ª—é—Ç–Ω–æ—ó –ø–∞—Ä–∏!")
            print("   –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—é CURRENCY_PAIRS –≤ real_config.py")
            sys.exit(1)
        
        combinations = updater.combinations
        if not combinations:
            print("‚ùå –ü–æ–º–∏–ª–∫–∞: –ù–µ –∑–Ω–∞–π–¥–µ–Ω–æ –∫–æ–º–±—ñ–Ω–∞—Ü—ñ–π –ø–∞—Ä/—Ç–∞–π–º—Ñ—Ä–µ–π–º—ñ–≤ –¥–ª—è –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è!")
            print("   –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—é ACTIVE_TIMEFRAMES –≤ real_config.py")
            sys.exit(1)
        
        enabled_pairs = get_enabled_pairs()
        disabled_pairs = [p for p in all_pairs if not p['enabled']]
        
        print(f"‚úÖ –ù–∞–ª–∞—à—Ç–æ–≤–∞–Ω–æ {len(all_pairs)} –≤–∞–ª—é—Ç–Ω–∏—Ö –ø–∞—Ä (–∞–∫—Ç–∏–≤–Ω–∏—Ö: {len(enabled_pairs)}, –Ω–µ–∞–∫—Ç–∏–≤–Ω–∏—Ö: {len(disabled_pairs)})")
        print(f"‚úÖ –ù–∞–ª–∞—à—Ç–æ–≤–∞–Ω–æ {len(updater.config['active_timeframes'])} —Ç–∞–π–º—Ñ—Ä–µ–π–º—ñ–≤")
        print(f"‚úÖ –í—Å—å–æ–≥–æ –∫–æ–º–±—ñ–Ω–∞—Ü—ñ–π –¥–ª—è –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è: {len(combinations)}")
        print("\nüìä –ö–æ–º–±—ñ–Ω–∞—Ü—ñ—ó –¥–ª—è –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è:")
        for combo in combinations[:10]:  # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–µ—Ä–≤—ã–µ 10
            status = "‚úÖ" if combo['enabled'] else "‚ö†Ô∏è"
            print(f"   {status} {combo['symbol']} {combo['timeframe']} (ID: {combo['symbol_id']}/{combo['timeframe_id']})")
        
        if len(combinations) > 10:
            print(f"   ... —Ç–∞ —â–µ {len(combinations) - 10} –∫–æ–º–±—ñ–Ω–∞—Ü—ñ–π")
        
        smart_schedule_mode = updater.config['data_update'].get('smart_schedule_mode', False)
        print(f"\nüîÑ –†–µ–∂–∏–º –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è: {'–ü–∞—Ä–∞–ª–µ–ª—å–Ω–∏–π' if updater.config['data_update'].get('parallel_downloads', True) else '–ü–æ—Å–ª—ñ–¥–æ–≤–Ω–∏–π'}")
        if smart_schedule_mode:
            active_schedules = []
            for tf, schedule in updater.config['data_update']['timeframe_schedules'].items():
                if schedule.get('enabled', True):
                    active_schedules.append(f"{tf}(–∫–æ–∂–Ω—ñ {schedule['interval_minutes']}—Ö–≤)")
            print(f"‚è±Ô∏è  –†–µ–∂–∏–º —Ä–æ–±–æ—Ç–∏: –†–æ–∑—É–º–Ω–∏–π —Ä–æ–∑–∫–ª–∞–¥ - {', '.join(active_schedules)}")
        else:
            print(f"‚è±Ô∏è  –Ü–Ω—Ç–µ—Ä–≤–∞–ª –æ–Ω–æ–≤–ª–µ–Ω–Ω—è: {updater.config['data_update']['update_interval']} —Å–µ–∫—É–Ω–¥")
        print("\nüöÄ –ó–∞–ø—É—Å–∫ —Å–∏—Å—Ç–µ–º–∏...")
        
        updater.run()
        
    except KeyboardInterrupt:
        print("\nüõë –ó—É–ø–∏–Ω–∫–∞ –∑–∞ –∑–∞–ø–∏—Ç–æ–º –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞")
    except Exception as e:
        print(f"üí• –ö—Ä–∏—Ç–∏—á–Ω–∞ –ø–æ–º–∏–ª–∫–∞ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—ó: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main() 